import requests
import json
import os
import re
from datetime import datetime
from collections import defaultdict

def fetch_m3u(url):
    try:
        response = requests.get(url, timeout=30)
        response.raise_for_status()
        return response.text
    except Exception as e:
        print(f"Error fetching M3U: {e}")
        return None


# ==============================
# ✅ FILTER
# ==============================
def is_sony_channel(channel_name):
    if not channel_name:
        return False
    name = channel_name.lower()
    return "sony" in name   # SonGhar


def detect_category(channel_name):
    name_lower = channel_name.lower()
    
    if any(word in name_lower for word in ['sports', 'ten 1', 'ten 2', 'ten 3', 'ten 4', 'ten 5', 'six']):
        return "Sports"
    if any(word in name_lower for word in ['max', 'pix', 'wah', 'movie']):
        return "Movies"
    if any(word in name_lower for word in ['yay', 'kids', 'cartoon']):
        return "Kids"
    if any(word in name_lower for word in ['marathi', 'aath', 'bengali', 'tamil', 'telugu', 'kannada']):
        return "Regional"
    if any(word in name_lower for word in ['set', 'sab', 'pal', 'sony tv', 'entertainment']):
        return "Entertainment"
    if any(word in name_lower for word in ['news', 'aaj tak', 'india tv', 'ndtv']):
        return "News"
    if any(word in name_lower for word in ['music', 'mtv', 'vh1', '9xm']):
        return "Music"

    return "Entertainment"


def parse_m3u(content):
    channels = []
    lines = content.strip().split('\n')
    i = 0

    while i < len(lines):
        line = lines[i].strip()

        if line.startswith('#EXTINF:'):
            channel_info = {}
            channel_info["props"] = []

            tvg_id = re.search(r'tvg-id="([^"]*)"', line)
            tvg_name = re.search(r'tvg-name="([^"]*)"', line)
            tvg_logo = re.search(r'tvg-logo="([^"]*)"', line)
            group = re.search(r'group-title="([^"]*)"', line)
            name_match = re.search(r',(.+)$', line)

            if tvg_id:
                channel_info['tvg_id'] = tvg_id.group(1)
            if tvg_name:
                channel_info['tvg_name'] = tvg_name.group(1)
            if tvg_logo:
                channel_info['tvg_logo'] = tvg_logo.group(1)

            if name_match:
                name = name_match.group(1).strip()
                channel_info['name'] = name
                channel_info['group_title'] = (
                    group.group(1).strip()
                    if group and group.group(1).strip()
                    else detect_category(name)
                )

            j = i + 1
            while j < len(lines):
                l = lines[j].strip()
                if l.startswith("#KODIPROP") or l.startswith("#EXTVLCOPT") or l.startswith("#EXTHTTP"):
                    channel_info["props"].append(l)
                elif l and not l.startswith("#"):
                    channel_info['url'] = l
                    channels.append(channel_info)
                    i = j
                    break
                j += 1

        i += 1

    return channels


def create_m3u(channels):
    m3u_content = '''#EXTM3U x-tvg-url="https://www.tsepg.cf/epg.xml.gz"
# ===============================
#  StreamFlex™ Official Playlist
#  AU • Secure • Private
#  Join: https://t.me/streamflex19
# ===============================

'''
    categories = defaultdict(list)
    for ch in channels:
        categories[ch.get('group_title', 'Entertainment')].append(ch)

    order = ['Entertainment', 'Movies', 'Sports', 'Kids', 'Regional', 'News', 'Music']
    final = [c for c in order if c in categories]
    final += sorted(c for c in categories if c not in order)

    for cat in final:
        m3u_content += f'# ========== {cat} ==========\n'
        for ch in categories[cat]:
            ext = "#EXTINF:-1"
            if ch.get("tvg_id"):
                ext += f' tvg-id="{ch["tvg_id"]}"'
            if ch.get("tvg_name"):
                ext += f' tvg-name="{ch["tvg_name"]}"'
            if ch.get("tvg_logo"):
                ext += f' tvg-logo="{ch["tvg_logo"]}"'
            ext += f' group-title="{cat}",{ch["name"]}\n'
            m3u_content += ext

            for p in ch.get("props", []):
                m3u_content += p + "\n"

            m3u_content += ch["url"] + "\n\n"

    m3u_content += '''# =====================================
# Generated by StreamFlex
# Thank you
# =====================================
'''
    return m3u_content


def create_json(channels):
    categories = defaultdict(list)
    for ch in channels:
        categories[ch['group_title']].append({
            "name": ch["name"],
            "tvg_id": ch.get("tvg_id", ""),
            "tvg_name": ch.get("tvg_name", ""),
            "logo": ch.get("tvg_logo", ""),
            "group": ch["group_title"],
            "url": ch["url"]
        })

    return json.dumps({
        "StreamFlex_A_updated_at": datetime.utcnow().isoformat() + "Z",
        "StreamFlex_SL_total_channels": len(channels),
        "total_categories": len(categories),
        "categories": categories,
        "all_channels": [c for cat in categories.values() for c in cat]
    }, indent=2, ensure_ascii=False)


def main():
    api_key = os.environ.get('API_KEY')
    if not api_key:
        print("ERROR: API_KEY environment variable not set!")
        return

    m3u_content = fetch_m3u(api_key)
    channels = parse_m3u(m3u_content)

    # ✅ FINAL FILTER
    channels = [ch for ch in channels if is_sony_channel(ch.get("name", ""))]

    with open("SL.m3u", "w", encoding="utf-8") as f:
        f.write(create_m3u(channels))

    with open("sl.json", "w", encoding="utf-8") as f:
        f.write(create_json(channels))

    print(f"✓ Sony channels processed: {len(channels)}")


if __name__ == "__main__":
    main()
